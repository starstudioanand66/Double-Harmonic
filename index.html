<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Aesthetic Scale Interface</title>
    <style>
        /* --- Aesthetic Dark Theme --- */
        :root {
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --primary-neon: #38bdf8;
            --accent-neon: #f472b6;
            --text-main: #f8fafc;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* --- Header --- */
        header {
            text-align: center;
            margin-bottom: 30px;
            z-index: 10;
        }

        h1 {
            font-size: 2.5rem;
            margin: 0;
            background: linear-gradient(to right, #fff, #94a3b8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 4px 20px rgba(0,0,0,0.5);
            letter-spacing: -1px;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* --- Controls --- */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
            background: var(--glass-bg);
            padding: 15px 25px;
            border-radius: 16px;
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        select {
            padding: 10px 20px;
            font-size: 1rem;
            background: rgba(0,0,0,0.3);
            border: 1px solid #475569;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            outline: none;
            transition: all 0.3s;
        }

        select:hover {
            border-color: var(--primary-neon);
        }

        button {
            padding: 10px 25px;
            font-size: 1rem;
            background: var(--primary-neon);
            color: #0f172a;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
            transition: transform 0.1s, box-shadow 0.2s;
        }

        button:hover {
            background: #7dd3fc;
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.5);
        }

        button:active {
            transform: scale(0.95);
        }

        /* --- Canvas Container --- */
        .canvas-scroll-container {
            width: 100%;
            max-width: 1200px;
            overflow-x: auto;
            padding-bottom: 20px;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #475569 transparent;
        }
        
        .canvas-scroll-container::-webkit-scrollbar {
            height: 8px;
        }
        .canvas-scroll-container::-webkit-scrollbar-thumb {
            background-color: #475569;
            border-radius: 4px;
        }

        .canvas-wrapper {
            position: relative;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            padding: 40px 20px 20px 20px; /* Extra top padding for shadows */
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 1px solid #334155;
            margin: 0 auto;
            width: max-content;
            min-width: 100%;
        }

        canvas {
            display: block;
            margin: 0 auto;
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
        }

        /* --- Theory Display --- */
        .theory-panel {
            margin-top: 30px;
            text-align: center;
            max-width: 700px;
            background: var(--glass-bg);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(10px);
        }

        .formula-box {
            font-family: 'Courier New', monospace;
            font-size: 1.4rem;
            font-weight: bold;
            color: #e2e8f0;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }

        .interval-wh { color: #94a3b8; }
        .interval-h { color: #64748b; }
        .interval-special { 
            color: var(--accent-neon); 
            text-shadow: 0 0 10px rgba(244, 114, 182, 0.5); 
        }

        .explanation {
            color: #cbd5e1;
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .explanation strong {
            color: var(--accent-neon);
        }

    </style>
</head>
<body>

    <header>
        <h1 id="mainTitle">Double Harmonic Minor Scale</h1>
        <div class="subtitle">Aesthetic 3D Simulation</div>
    </header>

    <div class="controls">
        <label for="rootSelect" style="align-self:center; font-weight:600;">Root:</label>
        <select id="rootSelect">
            <option value="C">C</option>
            <option value="C#">C# / Db</option>
            <option value="D">D</option>
            <option value="D#">D# / Eb</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="F#">F# / Gb</option>
            <option value="G">G</option>
            <option value="G#">G# / Ab</option>
            <option value="A">A</option>
            <option value="A#">A# / Bb</option>
            <option value="B">B</option>
        </select>

        <label for="scaleSelect" style="align-self:center; font-weight:600;">Scale:</label>
        <select id="scaleSelect">
            <option value="major">Major Scale</option>
            <option value="natural_minor">Natural Minor</option>
            <option value="harmonic_minor">Harmonic Minor</option>
            <option value="double_harmonic_minor" selected>Double Harmonic Minor</option>
        </select>

        <button id="playBtn">▶ Play Scale</button>
    </div>

    <div class="canvas-scroll-container">
        <div class="canvas-wrapper">
            <canvas id="pianoCanvas"></canvas>
        </div>
    </div>

    <div class="theory-panel">
        <div class="formula-box" id="formulaDisplay">
            H - <span class="interval-special">(WH)</span> - H - W - H - <span class="interval-special">(WH)</span> - H
        </div>
        <div class="explanation" id="explanationText">
            The <strong>Double Harmonic Minor</strong> scale features two augmented seconds (3 semitones). Visually represented by the glowing pink arcs.
        </div>
    </div>

    <script>
        /**
         * Aesthetic 3D Piano Simulation
         * Focus: Dark colors, Neon Glows, 3D Perspective
         */

        const canvas = document.getElementById('pianoCanvas');
        const ctx = canvas.getContext('2d');
        const rootSelect = document.getElementById('rootSelect');
        const scaleSelect = document.getElementById('scaleSelect');
        const mainTitle = document.getElementById('mainTitle');
        const formulaDisplay = document.getElementById('formulaDisplay');
        const explanationText = document.getElementById('explanationText');
        const playBtn = document.getElementById('playBtn');

        // --- Config ---
        const config = {
            whiteKeyWidth: 45,
            whiteKeyHeight: 180,
            blackKeyWidth: 28,
            blackKeyHeight: 110,
            keyDepth: 12, // 3D thickness
            startY: 100,
            
            // Colors
            whiteTop: ['#ffffff', '#e2e8f0'],
            whiteSide: '#94a3b8',
            blackTop: ['#334155', '#0f172a'],
            blackSide: '#020617',
            
            // Active: Dark Color with Light Glow
            activeDarkTop: ['#312e81', '#1e1b4b'], // Deep Indigo
            activeDarkSide: '#0f172a',
            activeGlow: '#818cf8', // Light Indigo Glow
            
            // Playing: Bright Light
            playingTop: ['#fef08a', '#facc15'], // Bright Yellow
            playingSide: '#a16207',
            playingGlow: '#ffff00',

            arcColor: 'rgba(255,255,255,0.4)',
            arcSpecial: '#f472b6', // Pink Neon
            textLight: '#f8fafc',
            textDark: '#1e293b'
        };

        // --- Music Theory Data ---
        const CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

        const SCALES = {
            major: {
                name: "Major Scale",
                intervals: [0, 2, 4, 5, 7, 9, 11, 12],
                degrees: ["1", "2", "3", "4", "5", "6", "7", "8"],
                formula: "W - W - H - W - W - W - H",
                desc: "The diatonic major scale."
            },
            natural_minor: {
                name: "Natural Minor Scale",
                intervals: [0, 2, 3, 5, 7, 8, 10, 12],
                degrees: ["1", "2", "3b", "4", "5", "6b", "7b", "8"],
                formula: "W - H - W - W - H - W - W",
                desc: "The natural minor (Aeolian) scale."
            },
            harmonic_minor: {
                name: "Harmonic Minor Scale",
                intervals: [0, 2, 3, 5, 7, 8, 11, 12],
                degrees: ["1", "2", "3b", "4", "5", "6b", "7", "8"],
                formula: "W - H - W - W - H - <span class='interval-special'>(WH)</span> - H",
                desc: "Raises the 7th degree, creating an augmented second between 6 and 7."
            },
            double_harmonic_minor: {
                name: "Double Harmonic Minor Scale",
                intervals: [0, 1, 4, 5, 7, 8, 11, 12],
                degrees: ["1", "2b", "3", "4", "5", "6b", "7", "8"],
                formula: "H - <span class='interval-special'>(WH)</span> - H - W - H - <span class='interval-special'>(WH)</span> - H",
                desc: "Features two augmented seconds (1½ steps) between 2-3 and 6-7."
            }
        };

        // --- State ---
        let state = {
            root: 'C',
            rootIndex: 0,
            scaleType: 'double_harmonic_minor',
            notes: [],
            playingIndex: -1 // Tracks which index in the active list is currently playing
        };

        let audioCtx;

        // --- Init ---
        function init() {
            resizeCanvas();
            updateSimulation();
            window.addEventListener('resize', () => {
                resizeCanvas();
                draw();
            });
        }

        function resizeCanvas() {
            // 3 Octaves approx: 21 white keys
            const numWhiteKeys = 21; 
            canvas.width = (numWhiteKeys * config.whiteKeyWidth) + 40;
            canvas.height = 400;
        }

        // --- Logic ---
        function updateSimulation() {
            state.rootIndex = CHROMATIC.indexOf(state.root);
            const scaleData = SCALES[state.scaleType];
            
            mainTitle.textContent = scaleData.name;
            formulaDisplay.innerHTML = scaleData.formula;
            explanationText.innerHTML = scaleData.desc;

            state.notes = generateScaleNotes(state.rootIndex, state.scaleType);
            draw();
        }

        function generateScaleNotes(rootIdx, scaleType) {
            const scale = SCALES[scaleType];
            const notes = [];
            
            // Generate 3 Octaves: Start 1 note before root, end 1 octave + 2 notes after (to see full range)
            // 3 octaves is 36 semitones.
            const startChromatic = Math.max(0, rootIdx - 1);
            const endChromatic = Math.min(35, rootIdx + 35); 

            for (let i = startChromatic; i <= endChromatic; i++) {
                let noteIndex = i % 12;
                let whiteKeysBefore = 0;
                
                // Calculate X Position based on white keys only
                for(let k=0; k<i; k++) {
                    if(![1,3,6,8,10].includes(k%12)) whiteKeysBefore++;
                }

                const isBlack = [1, 3, 6, 8, 10].includes(noteIndex);
                const name = getNoteName(i, scaleType, rootIdx);

                notes.push({
                    chromaticIndex: i,
                    name: name,
                    type: isBlack ? 'black' : 'white',
                    x: 20 + (whiteKeysBefore * config.whiteKeyWidth),
                    y: config.startY,
                    freq: 440 * Math.pow(2, (i - 9) / 12),
                    active: false,
                    degree: null
                });
            }

            // Mark Active Keys
            scale.intervals.forEach((intervalOffset, degIdx) => {
                let absIndex = rootIdx + intervalOffset;
                let key = notes.find(k => k.chromaticIndex === absIndex);
                if (key) {
                    key.active = true;
                    key.degree = scale.degrees[degIdx];
                }
            });

            return notes;
        }

        function getNoteName(absIndex, scaleType, rootIdx) {
            let index = absIndex % 12;
            let offset = absIndex - rootIdx;
            while(offset < 0) offset += 12;

            if (scaleType === 'double_harmonic_minor') {
                if (offset === 1 || offset === 8) return FLATS[index];
            } else if (scaleType === 'harmonic_minor') {
                if (offset === 8) return FLATS[index];
            } else if (scaleType === 'natural_minor') {
                if ([3, 8, 10].includes(offset)) return FLATS[index];
            }
            return CHROMATIC[index];
        }

        // --- Drawing ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw White Keys (Background Layer)
            state.notes.filter(n => n.type === 'white').forEach(note => drawKey3D(note));
            
            // Draw Black Keys (Foreground Layer)
            state.notes.filter(n => n.type === 'black').forEach(note => drawKey3D(note));

            // Draw Arcs
            const activeNotes = state.notes.filter(n => n.active);
            for (let i = 0; i < activeNotes.length - 1; i++) {
                drawArc(activeNotes[i], activeNotes[i+1]);
            }

            // Draw Labels
            activeNotes.forEach((note, index) => {
                drawLabel(note, index);
            });
        }

        function drawKey3D(note) {
            // Determine State
            const isActive = note.active;
            
            // Check if this specific note is currently playing
            const activeList = state.notes.filter(n => n.active);
            const listIndex = activeList.findIndex(n => n.chromaticIndex === note.chromaticIndex);
            const isPlaying = (listIndex === state.playingIndex);

            // Geometry
            const w = note.type === 'white' ? config.whiteKeyWidth : config.blackKeyWidth;
            const h = note.type === 'white' ? config.whiteKeyHeight : config.blackKeyHeight;
            const x = note.x + (note.type === 'black' ? (config.whiteKeyWidth - w)/2 : 0);
            let y = note.y;

            // 3D Lift Effect if playing
            const lift = isPlaying ? 8 : 0;
            y -= lift;

            // Define Colors
            let topColors, sideColor, glowColor, shadowBlur;

            if (isPlaying) {
                topColors = config.playingTop;
                sideColor = config.playingSide;
                glowColor = config.playingGlow;
                shadowBlur = 30;
            } else if (isActive) {
                topColors = config.activeDarkTop; // Dark fill
                sideColor = config.activeDarkSide;
                glowColor = config.activeGlow;    // Light glow
                shadowBlur = 15;
            } else {
                topColors = note.type === 'white' ? config.whiteTop : config.blackTop;
                sideColor = note.type === 'white' ? config.whiteSide : config.blackSide;
                glowColor = 'transparent';
                shadowBlur = 0;
            }

            ctx.save();

            // 1. Draw Shadow (Behind key)
            // If key lifts, shadow moves down and blurs more
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.filter = `blur(${isPlaying ? 8 : 2}px)`; // Native canvas blur for shadow
            ctx.fillRect(x + 5, y + 5, w, h);
            ctx.filter = 'none';

            // 2. Draw Side (The "Thickness" of the 3D key)
            // It sits below the top face
            ctx.fillStyle = sideColor;
            ctx.fillRect(x, y + h, w, config.keyDepth);

            // 3. Draw Top Face
            // Gradient for curvature
            const grad = ctx.createLinearGradient(x, y, x + w, y + h);
            grad.addColorStop(0, topColors[0]);
            grad.addColorStop(1, topColors[1]);
            
            ctx.fillStyle = grad;
            
            // Glow Effect for active/playing keys
            if (isActive || isPlaying) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = shadowBlur;
            }

            // Rounded Top Rect
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, [4, 4, 0, 0]);
            ctx.fill();
            
            // Border/Bevel
            if (isActive && !isPlaying) {
                ctx.strokeStyle = config.activeGlow;
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // High glossy reflection on top
            ctx.shadowBlur = 0; // Reset for gloss
            const glossGrad = ctx.createLinearGradient(x, y, x, y + h/2);
            glossGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
            glossGrad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = glossGrad;
            ctx.fill();

            ctx.restore();
        }

        function drawArc(n1, n2) {
            const x1 = n1.x + (n1.type === 'white' ? config.whiteKeyWidth/2 : n1.x + config.whiteKeyWidth/2);
            const x2 = n2.x + (n2.type === 'white' ? config.whiteKeyWidth/2 : n2.x + config.whiteKeyWidth/2);
            const y = n1.y - 15;

            const semitones = n2.chromaticIndex - n1.chromaticIndex;
            
            let label = "";
            let color = config.arcColor;
            let isSpecial = false;

            if (semitones === 1) label = "1/2";
            else if (semitones === 2) label = "1";
            else if (semitones === 3) {
                label = "1½";
                color = config.arcSpecial;
                isSpecial = true;
            }

            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = isSpecial ? 4 : 2;
            ctx.lineCap = 'round';
            
            if (isSpecial) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 10;
            }

            const cpY = y - 70 - (isSpecial ? 20 : 0);
            ctx.moveTo(x1, y);
            ctx.quadraticCurveTo((x1 + x2)/2, cpY, x2, y);
            ctx.stroke();
            ctx.restore();

            // Label
            ctx.save();
            ctx.fillStyle = isSpecial ? '#fff' : '#cbd5e1';
            ctx.font = isSpecial ? "bold 16px Arial" : "14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            const midX = (x1 + x2) / 2;
            const midY = (y + cpY) / 2;

            // Text background for readability
            const tw = ctx.measureText(label).width;
            ctx.fillStyle = 'rgba(15, 23, 42, 0.8)'; // Dark background behind text
            ctx.fillRect(midX - tw/2 - 4, midY - 10, tw + 8, 20);
            
            ctx.fillStyle = isSpecial ? config.arcSpecial : '#e2e8f0';
            ctx.fillText(label, midX, midY);
            ctx.restore();
        }

        function drawLabel(note, index) {
            const w = note.type === 'white' ? config.whiteKeyWidth : config.blackKeyWidth;
            const x = note.x + (note.type === 'black' ? (config.whiteKeyWidth - w)/2 : 0);
            const centerX = x + w/2;
            
            // Note Name
            ctx.fillStyle = (note.type === 'black') ? '#fff' : '#1e293b';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(note.name, centerX, note.y + (note.type==='black'?config.blackKeyHeight-15:config.whiteKeyHeight-15));

            // Degree Number
            ctx.fillStyle = (note.type === 'white') ? config.activeDarkTop[0] : '#fff';
            ctx.font = 'bold 12px Arial';
            ctx.fillText(note.degree, centerX, note.y + 30);
        }

        // --- Audio & Interaction ---

        function playTone(freq, time, duration) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sawtooth'; // Richer sound for 3D feel
            osc.frequency.value = freq;
            
            // Low pass filter to soften the sawtooth
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 2000;

            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.4, time + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            
            osc.start(time);
            osc.stop(time + duration);
        }

        playBtn.addEventListener('click', () => {
            const activeNotes = state.notes.filter(n => n.active);
            if (activeNotes.length === 0) return;

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const now = audioCtx.currentTime;
            const stepTime = 0.5;

            playBtn.disabled = true;
            playBtn.style.opacity = "0.7";

            activeNotes.forEach((note, i) => {
                const playTime = now + (i * stepTime);
                playTone(note.freq, playTime, 0.6);
                
                // Visual Sync using setTimeout relative to audio time
                setTimeout(() => {
                    state.playingIndex = i;
                    draw();
                }, (playTime - now) * 1000);
            });

            // Reset after last note
            setTimeout(() => {
                state.playingIndex = -1;
                draw();
                playBtn.disabled = false;
                playBtn.style.opacity = "1";
            }, (activeNotes.length * stepTime) * 1000 + 500);
        });

        // --- Event Listeners ---
        rootSelect.addEventListener('change', (e) => {
            state.root = e.target.value;
            updateSimulation();
        });

        scaleSelect.addEventListener('change', (e) => {
            state.scaleType = e.target.value;
            updateSimulation();
        });

        init();

    </script>
</body>
</html>